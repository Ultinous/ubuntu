.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.41.2.
.TH EMCC "1" "June 2013" "emcc (Emscripten GCC-like replacement) 1.4.7 ()" "User Commands"
.SH NAME
emcc \- Emscripten compiler frontend
.SH DESCRIPTION
emcc [options] file...
.SS "Most normal gcc/g++ options will work, for example:"
.TP
\fB\-\-help\fR
Display this information
.TP
\fB\-\-version\fR
Display compiler version information
.SS "Options that are modified or new in emcc include:"
.TP
\fB\-O0\fR
No optimizations (default)
.TP
\fB\-O1\fR
Simple optimizations, including asm.js, LLVM \fB\-O1\fR
optimizations, and no runtime assertions
or C++ exception catching (to re\-enable
C++ exception catching, use
\fB\-s\fR DISABLE_EXCEPTION_CATCHING=0 ).
(For details on the affects of different
opt levels, see apply_opt_level() in
tools/shared.py and also src/settings.js.)
Note: Optimizations are only done when
compiling to JavaScript, not to intermediate
bitcode, *unless* you build with
EMCC_OPTIMIZE_NORMALLY=1 (not recommended
unless you know what you are doing!)
.TP
\fB\-O2\fR
As \fB\-O1\fR, plus the relooper (loop recreation),
LLVM \fB\-O2\fR optimizations, and
.IP
\fB\-s\fR ALIASING_FUNCTION_POINTERS=1
.TP
\fB\-O3\fR
As \fB\-O2\fR, plus dangerous optimizations that may
break the generated code! This adds
.IP
\fB\-s\fR FORCE_ALIGNED_MEMORY=1
\fB\-s\fR DOUBLE_MODE=0
\fB\-s\fR PRECISE_I64_MATH=0
\fB\-\-closure\fR 1
\fB\-\-llvm\-lto\fR 1
.IP
This is not recommended at all. A better idea
is to try each of these separately on top of
\fB\-O2\fR to see what works. See the wiki and
src/settings.js (for the \fB\-s\fR options) for more
information.
.TP
\fB\-s\fR OPTION=VALUE
JavaScript code generation option passed
into the emscripten compiler. For the
available options, see src/settings.js
Note that for options that are lists, you
need quotation marks in most shells, for
example
.IP
\fB\-s\fR RUNTIME_LINKED_LIBS="['liblib.so']"
.IP
or
.IP
\fB\-s\fR "RUNTIME_LINKED_LIBS=['liblib.so']"
.IP
(without the external "s in either of those,
you would get an error)
.IP
You can also specify a file from which the
value would be read, for example,
.IP
\fB\-s\fR DEAD_FUNCTIONS=@/path/to/file
.IP
The contents of \fI/path/to/file\fP will be read,
JSON.parsed and set into DEAD_FUNCTIONS (so
the file could contain
.IP
["_func1", "func2"]
.IP
). Note that the path must be absolute, not
relative.
.TP
\fB\-g\fR
Use debug info. Note that you need this during
the last compilation phase from bitcode to
JavaScript, or else we will remove it by
default in \fB\-O1\fR and above.
In \fB\-O0\fR, line numbers wil be shown in the
generated code. In \fB\-O1\fR and above, the optimizer
removes those comments. This flag does however
have the effect of disabling anything that
causes name mangling or minification (closure
or the registerize pass).
.TP
\fB\-\-typed\-arrays\fR <mode>
0: No typed arrays
1: Parallel typed arrays
2: Shared (C\-like) typed arrays (default)
.TP
\fB\-\-llvm\-opts\fR <level>
0: No LLVM optimizations (default in \fB\-O0\fR)
1: \fB\-O1\fR LLVM optimizations (default in \fB\-O1\fR)
2: \fB\-O2\fR LLVM optimizations
3: \fB\-O3\fR LLVM optimizations (default in \fB\-O2\fR+)
.TP
\fB\-\-llvm\-lto\fR <level>
0: No LLVM LTO (default in \fB\-O2\fR and below)
1: LLVM LTO (default in \fB\-O3\fR)
Note: If LLVM optimizations are not run
(see \fB\-\-llvm\-opts\fR), setting this to 1 has no
effect.
.TP
\fB\-\-closure\fR <on>
0: No closure compiler (default in \fB\-O2\fR and below)
1: Run closure compiler. This greatly reduces
code size and may in some cases increase
runtime speed (although the opposite can also
occur). Note that it takes time to run, and
may require some changes to the code. This
is run by default in \fB\-O3\fR.
.IP
In asm.js mode, closure will only be used on the
\&'shell' code around the compiled code (the
compiled code will be processed by the custom
asm.js minifier).
.IP
Note: If closure compiler hits an out\-of\-memory,
try adjusting JAVA_HEAP_SIZE in the environment
(for example, to 4096m for 4GB).
.TP
\fB\-\-js\-transform\fR <cmd>
<cmd> will be called on the generated code
before it is optimized. This lets you modify
the JavaScript, for example adding some code
or removing some code, in a way that those
modifications will be optimized together with
the generated code properly. <cmd> will be
called with the filename of the generated
code as a parameter; to modify the code, you
can read the original data and then append to
it or overwrite it with the modified data.
<cmd> is interpreted as a space\-separated
list of arguments, for example, <cmd> of
"python processor.py" will cause a python
script to be run.
.TP
\fB\-\-pre\-js\fR <file>
A file whose contents are added before the
generated code. This is done *before*
optimization, so it will be minified
properly if closure compiler is run.
.TP
\fB\-\-post\-js\fR <file>
A file whose contents are added after the
generated code This is done *before*
optimization, so it will be minified
properly if closure compiler is run.
.TP
\fB\-\-embed\-file\fR <file>
A file to embed inside the generated
JavaScript. The compiled code will be able
to access the file in the current directory
with the same name as given here. So if
you do \fB\-\-embed\-file\fR dir/file.dat, then
(1) dir/file.dat must exist relative to
where you run emcc, and (2) your compiled
code will be able to find the file by
reading that same path, dir/file.dat.
If a directory is passed here, its entire
contents will be embedded.
.TP
\fB\-\-preload\-file\fR <name>
A file to preload before running the
compiled code asynchronously. Otherwise
similar to \fB\-\-embed\-file\fR, except that this
option is only relevant when generating
HTML (it uses asynchronous binary XHRs),
or JS that will be used in a web page.
If a directory is passed here, its entire
contents will be preloaded.
Preloaded files are stored in filename.data,
where filename.html is the main file you
are compiling to. To run your code, you
will need both the .html and the .data.
.IP
emcc runs tools/file_packager.py to do the
actual packaging of embedded and preloaded
files. You can run the file packager yourself
if you want, see docs inside that file. You
should then put the output of the file packager
in an emcc \fB\-\-pre\-js\fR, so that it executes before
your main compiled code (or run it before in
some other way).
.TP
\fB\-\-compression\fR <codec>
Compress both the compiled code and embedded/
preloaded files. <codec> should be a triple,
.IP
<native_encoder>,<js_decoder>,<js_name>
.IP
where native_encoder is a native executable
that compresses stdin to stdout (the simplest
possible interface), js_decoder is a
JavaScript file that implements a decoder,
and js_name is the name of the function to
call in the decoder file (which should
receive an array/typed array and return
an array/typed array.
Compression only works when generating HTML.
When compression is on, all filed specified
to be preloaded are compressed in one big
archive, which is given the same name as the
output HTML but with suffix .data.compress
.TP
\fB\-\-minify\fR <on>
0: Do not minify the generated JavaScript's
whitespace (default in \fB\-O0\fR, \fB\-O1\fR, or if
\fB\-g\fR is used)
.IP
1: Minify the generated JavaScript's
.IP
whitespace (default in \fB\-O2\fR+, assuming
\fB\-g\fR is not used)
.TP
\fB\-\-split\fR <size>
Splits the resulting javascript file into pieces
to ease debugging. This option only works if
Javascript is generated (target \fB\-o\fR <name>.js).
Files with function declarations must be loaded
before main file upon execution.
.IP
Without "\-g" option:
.IP
Creates files with function declarations up
to the given size with the suffix
"_functions.partxxx.js" and a main file with
the suffix ".js".
.IP
With "\-g" option:
.IP
Recreates the directory structure of the C
source files and stores function declarations
in their respective C files with the suffix
".js". If such a file exceeds the given size,
files with the suffix ".partxxx.js" are created.
The main file resides in the base directory and
has the suffix ".js".
.TP
\fB\-\-bind\fR
Compiles the source code using the "embind"
bindings approach, which connects C/C++ and JS.
.TP
\fB\-\-ignore\-dynamic\-linking\fR Normally emcc will treat dynamic linking like
static linking, by linking in the code from
the dynamic library. This fails if the same
dynamic library is linked more than once.
With this option, dynamic linking is ignored,
which allows the build system to proceed without
errors. However, you will need to manually
link to the shared libraries later on yourself.
.TP
\fB\-\-shell\-file\fR <path>
The path name to a skeleton HTML file used
when generating HTML output. The shell file
used needs to have this token inside it:
{{{ SCRIPT_CODE }}}
Note that this argument is ignored if a
target other than HTML is specified using
the \fB\-o\fR option.
.TP
\fB\-\-js\-library\fR <lib>
A JavaScript library to use in addition to
those in Emscripten's src/library_*
.TP
\fB\-v\fR
Turns on verbose output. This will pass
\fB\-v\fR to Clang, and also enable EMCC_DEBUG
to details emcc's operations
.TP
\fB\-\-jcache\fR
Use a JavaScript cache. This is disabled by
default. When enabled, emcc will store the
results of compilation in a cache and check
the cache when compiling later, something
like what ccache does. This allows incremental
builds \- where you are compiling a large
program but only modified a small part of it \-
to be much faster (at the cost of more disk
IO for cache accesses). Note that you need
to enable \fB\-\-jcache\fR for both loading and saving
of data, so you must enable it on a full build
for a later incremental build (where you also
enable it) to be sped up.
.IP
Caching works separately on 4 parts of compilation:
\&'pre' which is types and global variables; that
information is then fed into 'funcs' which are
the functions (which we parallelize), and then
\&'post' which adds final information based on
the functions (e.g., do we need long64 support
code). Finally, 'jsfuncs' are JavaScript\-level
optimizations. Each of the 4 parts can be cached
separately, but note that they can affect each
other: If you recompile a single C++ file that
changes a global variable \- e.g., adds, removes
or modifies a global variable, say by adding
a printf or by adding a compile\-time timestamp,
then 'pre' cannot be loaded from the cache. And
since 'pre's output is sent to 'funcs' and 'post',
they will get invalidated as well, and only
\&'jsfuncs' will be cached. So avoid modifying
globals to let caching work fully.
.IP
To work around the problem mentioned in the
previous paragraph, you can use
.IP
emscripten_jcache_printf
.IP
when adding debug printfs to your code. That
function is specially preprocessed so that it
does not create a constant string global for
its first argument. See emscripten.h for more
details. Note in particular that you need to
already have a call to that function in your
code *before* you add one and do an incremental
build, so that adding an external reference
(also a global property) does not invalidate
everything.
.IP
Note that you should use \fB\-g\fR during the linking
stage (bitcode to JS), for jcache to work
(otherwise, JS minification can confuse it).
.TP
\fB\-\-clear\-cache\fR
Manually clears the cache of compiled
emscripten system libraries (libc++,
libc++abi, libc). This is normally
handled automatically, but if you update
llvm in\-place (instead of having a different
directory for a new version), the caching
mechanism can get confused. Clearing the
cache can fix weird problems related to
cache incompatibilities, like clang failing
to link with library files. This also clears
other cached data like the jcache and
the bootstrapped relooper. After the cache
is cleared, this process will exit.
.TP
\fB\-\-save\-bc\fR PATH
When compiling to JavaScript or HTML, this
option will save a copy of the bitcode to
the specified path. The bitcode will include
all files being linked, including standard
libraries, and after any link\-time optimizations
(if any).
.TP
\fB\-\-memory\-init\-file\fR <on>
If on, we generate a separate memory initialization
file. This is more efficient than storing the
memory initialization data embedded inside
JavaScript as text. (default is off)
.PP
The target file, if specified (\fB\-o\fR <target>), defines what will
be generated:
.TP
<name>.js
JavaScript
.TP
<name>.html
HTML with embedded JavaScript
.TP
<name>.bc
LLVM bitcode (default)
.TP
<name>.o
LLVM bitcode (same as .bc)
.PP
(Note that if \fB\-\-memory\-init\-file\fR is used, then in addition to a
\&.js or .html file that is generated, a .mem file will also appear.)
.PP
The \fB\-c\fR option (which tells gcc not to run the linker) will
cause LLVM bitcode to be generated, as emcc only generates
JavaScript in the final linking stage of building.
.PP
The input file(s) can be either source code files that
Clang can handle (C or C++), LLVM bitcode in binary form,
or LLVM assembly files in human\-readable form.
.PP
emcc is affected by several environment variables. For details, view
the source of emcc (search for 'os.environ').
.PP
emcc: supported targets: llvm bitcode, javascript, NOT elf
(autoconf likes to see elf above to enable shared object support)
.SH COPYRIGHT
Copyright \(co 2013 the Emscripten authors (see AUTHORS.txt)
This is free and open source software under the MIT license.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
.SH "SEE ALSO"
The full documentation for
.B emcc
is maintained as a Texinfo manual.  If the
.B info
and
.B emcc
programs are properly installed at your site, the command
.IP
.B info emcc
.PP
should give you access to the complete manual.
