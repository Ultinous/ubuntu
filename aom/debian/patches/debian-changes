The Debian packaging of aom is maintained in git, using the merging
workflow described in dgit-maint-merge(7).  There isn't a patch queue
that can be represented as a quilt series.

A detailed breakdown of the changes is available from their canonical
representation - git commits in the packaging repository.  For
example, to see the changes made by the Debian maintainer in the first
upload of upstream version 1.2.3, you could use:

    % git clone https://git.dgit.debian.org/aom
    % cd aom
    % git log --oneline 1.2.3..debian/1.2.3-1 -- . ':!debian'

(If you have dgit, use `dgit clone aom`, rather than plain `git
clone`.)

A single combined diff, containing all the changes, follows.
--- aom-1.0.0.errata1.orig/CHANGELOG
+++ aom-1.0.0.errata1/CHANGELOG
@@ -1,631 +1,5 @@
-Next Release
-  - Incompatible changes:
-    The AV1 encoder's default keyframe interval changed to 128 from 9999.
-    Support for armv6 was removed.
+2018-06-28 v1.0.0
+  AOMedia Codec Workgroup Approved version 1.0
 
 2016-04-07 v0.1.0 "AOMedia Codec 1"
   This release is the first Alliance for Open Media codec.
-2015-11-09 v1.5.0 "Javan Whistling Duck"
-  This release improves upon the VP9 encoder and speeds up the encoding and
-  decoding processes.
-
-  - Upgrading:
-    This release is ABI incompatible with 1.4.0. It drops deprecated VP8
-    controls and adds a variety of VP9 controls for testing.
-
-    The vpxenc utility now prefers VP9 by default.
-
-  - Enhancements:
-    Faster VP9 encoding and decoding
-    Smaller library size by combining functions used by VP8 and VP9
-
-  - Bug Fixes:
-    A variety of fuzzing issues
-
-2015-04-03 v1.4.0 "Indian Runner Duck"
-  This release includes significant improvements to the VP9 codec.
-
-  - Upgrading:
-    This release is ABI incompatible with 1.3.0. It drops the compatibility
-    layer, requiring VPX_IMG_FMT_* instead of IMG_FMT_*, and adds several codec
-    controls for VP9.
-
-  - Enhancements:
-    Faster VP9 encoding and decoding
-    Multithreaded VP9 decoding (tile and frame-based)
-    Multithreaded VP9 encoding - on by default
-    YUV 4:2:2 and 4:4:4 support in VP9
-    10 and 12bit support in VP9
-    64bit ARM support by replacing ARM assembly with intrinsics
-
-  - Bug Fixes:
-    Fixes a VP9 bitstream issue in Profile 1. This only affected non-YUV 4:2:0
-    files.
-
-  - Known Issues:
-    Frame Parallel decoding fails for segmented and non-420 files.
-
-2013-11-15 v1.3.0 "Forest"
-  This release introduces the VP9 codec in a backward-compatible way.
-  All existing users of VP8 can continue to use the library without
-  modification. However, some VP8 options do not map to VP9 in the same manner.
-
-  The VP9 encoder in this release is not feature complete. Users interested in
-  the encoder are advised to use the git master branch and discuss issues on
-  libvpx mailing lists.
-
-  - Upgrading:
-    This release is ABI and API compatible with Duclair (v1.0.0). Users
-    of older releases should refer to the Upgrading notes in this document
-    for that release.
-
-  - Enhancements:
-      Get rid of bashisms in the main build scripts
-      Added usage info on command line options
-      Add lossless compression mode
-      Dll build of libvpx
-      Add additional Mac OS X targets: 10.7, 10.8 and 10.9 (darwin11-13)
-      Add option to disable documentation
-      configure: add --enable-external-build support
-      make: support V=1 as short form of verbose=yes
-      configure: support mingw-w64
-      configure: support hardfloat armv7 CHOSTS
-      configure: add support for android x86
-      Add estimated completion time to vpxenc
-      Don't exit on decode errors in vpxenc
-      vpxenc: support scaling prior to encoding
-      vpxdec: support scaling output
-      vpxenc: improve progress indicators with --skip
-      msvs: Don't link to winmm.lib
-      Add a new script for producing vcxproj files
-      Produce Visual Studio 10 and 11 project files
-      Produce Windows Phone project files
-      msvs-build: use msbuild for vs >= 2005
-      configure: default configure log to config.log
-      Add encoding option --static-thresh
-
-  - Speed:
-      Miscellaneous speed optimizations for VP8 and VP9.
-
-  - Quality:
-      In general, quality is consistent with the Eider release.
-
-  - Bug Fixes:
-      This release represents approximately a year of engineering effort,
-      and contains multiple bug fixes. Please refer to git history for details.
-
-
-2012-12-21 v1.2.0
-  This release acts as a checkpoint for a large amount of internal refactoring
-  and testing. It also contains a number of small bugfixes, so all users are
-  encouraged to upgrade.
-
-  - Upgrading:
-    This release is ABI and API compatible with Duclair (v1.0.0). Users
-    of older releases should refer to the Upgrading notes in this
-    document for that release.
-
-  - Enhancements:
-      VP8 optimizations for MIPS dspr2
-      vpxenc: add -quiet option
-
-  - Speed:
-      Encoder and decoder speed is consistent with the Eider release.
-
-  - Quality:
-      In general, quality is consistent with the Eider release.
-
-      Minor tweaks to ARNR filtering
-      Minor improvements to real time encoding with multiple temporal layers
-
-  - Bug Fixes:
-      Fixes multithreaded encoder race condition in loopfilter
-      Fixes multi-resolution threaded encoding
-      Fix potential encoder dead-lock after picture resize
-
-
-2012-05-09 v1.1.0 "Eider"
-  This introduces a number of enhancements, mostly focused on real-time
-  encoding. In addition, it fixes a decoder bug (first introduced in
-  Duclair) so all users of that release are encouraged to upgrade.
-
-  - Upgrading:
-    This release is ABI and API compatible with Duclair (v1.0.0). Users
-    of older releases should refer to the Upgrading notes in this
-    document for that release.
-
-    This release introduces a new temporal denoiser, controlled by the
-    VP8E_SET_NOISE_SENSITIVITY control. The temporal denoiser does not
-    currently take a strength parameter, so the control is effectively
-    a boolean - zero (off) or non-zero (on). For compatibility with
-    existing applications, the values accepted are the same as those
-    for the spatial denoiser (0-6). The temporal denoiser is enabled
-    by default, and the older spatial denoiser may be restored by
-    configuring with --disable-temporal-denoising. The temporal denoiser
-    is more computationally intensive than the spatial one.
-
-    This release removes support for a legacy, decode only API that was
-    supported, but deprecated, at the initial release of libvpx
-    (v0.9.0). This is not expected to have any impact. If you are
-    impacted, you can apply a reversion to commit 2bf8fb58 locally.
-    Please update to the latest libvpx API if you are affected.
-
-  - Enhancements:
-      Adds a motion compensated temporal denoiser to the encoder, which
-      gives higher quality than the older spatial denoiser. (See above
-      for notes on upgrading).
-
-      In addition, support for new compilers and platforms were added,
-      including:
-        improved support for XCode
-        Android x86 NDK build
-        OS/2 support
-        SunCC support
-
-      Changing resolution with vpx_codec_enc_config_set() is now
-      supported. Previously, reinitializing the codec was required to
-      change the input resolution.
-
-      The vpxenc application has initial support for producing multiple
-      encodes from the same input in one call. Resizing is not yet
-      supported, but varying other codec parameters is. Use -- to
-      delineate output streams. Options persist from one stream to the
-      next.
-
-      Also, the vpxenc application will now use a keyframe interval of
-      5 seconds by default. Use the --kf-max-dist option to override.
-
-  - Speed:
-      Decoder performance improved 2.5% versus Duclair. Encoder speed is
-      consistent with Duclair for most material. Two pass encoding of
-      slideshow-like material will see significant improvements.
-
-      Large realtime encoding speed gains at a small quality expense are
-      possible by configuring the on-the-fly bitpacking experiment with
-      --enable-onthefly-bitpacking. Realtime encoder can be up to 13%
-      faster (ARM) depending on the number of threads and bitrate
-      settings. This technique sees constant gain over the 5-16 speed
-      range. For VC style input the loss seen is up to 0.2dB. See commit
-      52cf4dca for further details.
-
-  - Quality:
-      On the whole, quality is consistent with the Duclair release. Some
-      tweaks:
-
-        Reduced blockiness in easy sections by applying a penalty to
-        intra modes.
-
-        Improved quality of static sections (like slideshows) with
-        two pass encoding.
-
-        Improved keyframe sizing with multiple temporal layers
-
-  - Bug Fixes:
-      Corrected alt-ref contribution to frame rate for visible updates
-      to the alt-ref buffer. This affected applications making manual
-      usage of the frame reference flags, or temporal layers.
-
-      Additional constraints were added to disable multi-frame quality
-      enhancement (MFQE) in sections of the frame where there is motion.
-      (#392)
-
-      Fixed corruption issues when vpx_codec_enc_config_set() was called
-      with spatial resampling enabled.
-
-      Fixed a decoder error introduced in Duclair where the segmentation
-      map was not being reinitialized on keyframes (#378)
-
-
-2012-01-27 v1.0.0 "Duclair"
-  Our fourth named release, focused on performance and features related to
-  real-time encoding. It also fixes a decoder crash bug introduced in
-  v0.9.7, so all users of that release are encouraged to upgrade.
-
-  - Upgrading:
-      This release is ABI incompatible with prior releases of libvpx, so the
-      "major" version number has been bumped to 1. You must recompile your
-      applications against the latest version of the libvpx headers. The
-      API remains compatible, and this should not require code changes in most
-      applications.
-
-  - Enhancements:
-      This release introduces several substantial new features to the encoder,
-      of particular interest to real time streaming applications.
-
-      Temporal scalability allows the encoder to produce a stream that can
-      be decimated to different frame rates, with independent rate targetting
-      for each substream.
-
-      Multiframe quality enhancement postprocessing can make visual quality
-      more consistent in the presence of frames that are substantially
-      different quality than the surrounding frames, as in the temporal
-      scalability case and in some forced keyframe scenarios.
-
-      Multiple-resolution encoding support allows the encoding of the
-      same content at different resolutions faster than encoding them
-      separately.
-
-  - Speed:
-      Optimization targets for this release included the decoder and the real-
-      time modes of the encoder. Decoder speed on x86 has improved 10.5% with
-      this release. Encoder improvements followed a curve where speeds 1-3
-      improved 4.0%-1.5%, speeds 4-8 improved <1%, and speeds 9-16 improved
-      1.5% to 10.5%, respectively. "Best" mode speed is consistent with the
-      Cayuga release.
-
-  - Quality:
-      Encoder quality in the single stream case is consistent with the Cayuga
-      release.
-
-  - Bug Fixes:
-      This release fixes an OOB read decoder crash bug present in v0.9.7
-      related to the clamping of motion vectors in SPLITMV blocks. This
-      behavior could be triggered by corrupt input or by starting
-      decoding from a P-frame.
-
-
-2011-08-15 v0.9.7-p1 "Cayuga" patch 1
-  This is an incremental bugfix release against Cayuga. All users of that
-  release are strongly encouraged to upgrade.
-
-    - Fix potential OOB reads (cdae03a)
-
-          An unbounded out of bounds read was discovered when the
-          decoder was requested to perform error concealment (new in
-          Cayuga) given a frame with corrupt partition sizes.
-
-          A bounded out of bounds read was discovered affecting all
-          versions of libvpx. Given an multipartition input frame that
-          is truncated between the mode/mv partition and the first
-          residiual paritition (in the block of partition offsets), up
-          to 3 extra bytes could have been read from the source buffer.
-          The code will not take any action regardless of the contents
-          of these undefined bytes, as the truncated buffer is detected
-          immediately following the read based on the calculated
-          starting position of the coefficient partition.
-
-    - Fix potential error concealment crash when the very first frame
-      is missing or corrupt (a609be5)
-
-    - Fix significant artifacts in error concealment (a4c2211, 99d870a)
-
-    - Revert 1-pass CBR rate control changes (e961317)
-      Further testing showed this change produced undesirable visual
-      artifacts, rolling back for now.
-
-
-2011-08-02 v0.9.7 "Cayuga"
-  Our third named release, focused on a faster, higher quality, encoder.
-
-  - Upgrading:
-    This release is backwards compatible with Aylesbury (v0.9.5) and
-    Bali (v0.9.6). Users of older releases should refer to the Upgrading
-    notes in this document for that release.
-
-  - Enhancements:
-          Stereo 3D format support for vpxenc
-          Runtime detection of available processor cores.
-          Allow specifying --end-usage by enum name
-          vpxdec: test for frame corruption
-          vpxenc: add quantizer histogram display
-          vpxenc: add rate histogram display
-          Set VPX_FRAME_IS_DROPPABLE
-          update configure for ios sdk 4.3
-          Avoid text relocations in ARM vp8 decoder
-          Generate a vpx.pc file for pkg-config.
-          New ways of passing encoded data between encoder and decoder.
-
-  - Speed:
-      This release includes across-the-board speed improvements to the
-      encoder. On x86, these measure at approximately 11.5% in Best mode,
-      21.5% in Good mode (speed 0), and 22.5% in Realtime mode (speed 6).
-      On ARM Cortex A9 with Neon extensions, real-time encoding of video
-      telephony content is 35% faster than Bali on single core and 48%
-      faster on multi-core. On the NVidia Tegra2 platform, real time
-      encoding is 40% faster than Bali.
-
-      Decoder speed was not a priority for this release, but improved
-      approximately 8.4% on x86.
-
-          Reduce motion vector search on alt-ref frame.
-          Encoder loopfilter running in its own thread
-          Reworked loopfilter to precalculate more parameters
-          SSE2/SSSE3 optimizations for build_predictors_mbuv{,_s}().
-          Make hor UV predict ~2x faster (73 vs 132 cycles) using SSSE3.
-          Removed redundant checks
-          Reduced structure sizes
-          utilize preload in ARMv6 MC/LPF/Copy routines
-          ARM optimized quantization, dfct, variance, subtract
-          Increase chrow row alignment to 16 bytes.
-          disable trellis optimization for first pass
-          Write SSSE3 sub-pixel filter function
-          Improve SSE2 half-pixel filter funtions
-          Add vp8_sub_pixel_variance16x8_ssse3 function
-          Reduce unnecessary distortion computation
-          Use diamond search to replace full search
-          Preload reference area in sub-pixel motion search (real-time mode)
-
-  - Quality:
-      This release focused primarily on one-pass use cases, including
-      video conferencing. Low latency data rate control was significantly
-      improved, improving streamability over bandwidth constrained links.
-      Added support for error concealment, allowing frames to maintain
-      visual quality in the presence of substantial packet loss.
-
-          Add rc_max_intra_bitrate_pct control
-          Limit size of initial keyframe in one-pass.
-          Improve framerate adaptation
-          Improved 1-pass CBR rate control
-          Improved KF insertion after fades to still.
-          Improved key frame detection.
-          Improved activity masking (lower PSNR impact for same SSIM boost)
-          Improved interaction between GF and ARFs
-          Adding error-concealment to the decoder.
-          Adding support for independent partitions
-          Adjusted rate-distortion constants
-
-
-  - Bug Fixes:
-          Removed firstpass motion map
-          Fix parallel make install
-          Fix multithreaded encoding for 1 MB wide frame
-          Fixed iwalsh_neon build problems with RVDS4.1
-          Fix semaphore emulation, spin-wait intrinsics on Windows
-          Fix build with xcode4 and simplify GLOBAL.
-          Mark ARM asm objects as allowing a non-executable stack.
-          Fix vpxenc encoding incorrect webm file header on big endian
-
-
-2011-03-07 v0.9.6 "Bali"
-  Our second named release, focused on a faster, higher quality, encoder.
-
-  - Upgrading:
-    This release is backwards compatible with Aylesbury (v0.9.5). Users
-    of older releases should refer to the Upgrading notes in this
-    document for that release.
-
-  - Enhancements:
-      vpxenc --psnr shows a summary when encode completes
-      --tune=ssim option to enable activity masking
-      improved postproc visualizations for development
-      updated support for Apple iOS to SDK 4.2
-      query decoder to determine which reference frames were updated
-      implemented error tracking in the decoder
-      fix pipe support on windows
-
-  - Speed:
-      Primary focus was on good quality mode, speed 0. Average improvement
-      on x86 about 40%, up to 100% on user-generated content at that speed.
-      Best quality mode speed improved 35%, and realtime speed 10-20%. This
-      release also saw significant improvement in realtime encoding speed
-      on ARM platforms.
-
-        Improved encoder threading
-        Dont pick encoder filter level when loopfilter is disabled.
-        Avoid double copying of key frames into alt and golden buffer
-        FDCT optimizations.
-        x86 sse2 temporal filter
-        SSSE3 version of fast quantizer
-        vp8_rd_pick_best_mbsegmentation code restructure
-        Adjusted breakout RD for SPLITMV
-        Changed segmentation check order
-        Improved rd_pick_intra4x4block
-        Adds armv6 optimized variance calculation
-        ARMv6 optimized sad16x16
-        ARMv6 optimized half pixel variance calculations
-        Full search SAD function optimization in SSE4.1
-        Improve MV prediction accuracy to achieve performance gain
-        Improve MV prediction in vp8_pick_inter_mode() for speed>3
-
-  - Quality:
-      Best quality mode improved PSNR 6.3%, and SSIM 6.1%. This release
-      also includes support for "activity masking," which greatly improves
-      SSIM at the expense of PSNR. For now, this feature is available with
-      the --tune=ssim option. Further experimentation in this area
-      is ongoing. This release also introduces a new rate control mode
-      called "CQ," which changes the allocation of bits within a clip to
-      the sections where they will have the most visual impact.
-
-        Tuning for the more exact quantizer.
-        Relax rate control for last few frames
-        CQ Mode
-        Limit key frame quantizer for forced key frames.
-        KF/GF Pulsing
-        Add simple version of activity masking.
-        make rdmult adaptive for intra in quantizer RDO
-        cap the best quantizer for 2nd order DC
-        change the threshold of DC check for encode breakout
-
-  - Bug Fixes:
-      Fix crash on Sparc Solaris.
-      Fix counter of fixed keyframe distance
-      ARNR filter pointer update bug fix
-      Fixed use of motion percentage in KF/GF group calc
-      Changed condition for using RD in Intra Mode
-      Fix encoder real-time only configuration.
-      Fix ARM encoder crash with multiple token partitions
-      Fixed bug first cluster timecode of webm file is wrong.
-      Fixed various encoder bugs with odd-sized images
-      vp8e_get_preview fixed when spatial resampling enabled
-      quantizer: fix assertion in fast quantizer path
-      Allocate source buffers to be multiples of 16
-      Fix for manual Golden frame frequency
-      Fix drastic undershoot in long form content
-
-
-2010-10-28 v0.9.5 "Aylesbury"
-  Our first named release, focused on a faster decoder, and a better encoder.
-
-  - Upgrading:
-    This release incorporates backwards-incompatible changes to the
-    ivfenc and ivfdec tools. These tools are now called vpxenc and vpxdec.
-
-    vpxdec
-      * the -q (quiet) option has been removed, and replaced with
-        -v (verbose). the output is quiet by default. Use -v to see
-        the version number of the binary.
-
-      * The default behavior is now to write output to a single file
-        instead of individual frames. The -y option has been removed.
-        Y4M output is the default.
-
-      * For raw I420/YV12 output instead of Y4M, the --i420 or --yv12
-        options must be specified.
-
-          $ ivfdec -o OUTPUT INPUT
-          $ vpxdec --i420 -o OUTPUT INPUT
-
-      * If an output file is not specified, the default is to write
-        Y4M to stdout. This makes piping more natural.
-
-          $ ivfdec -y -o - INPUT | ...
-          $ vpxdec INPUT | ...
-
-      * The output file has additional flexibility for formatting the
-        filename. It supports escape characters for constructing a
-        filename from the width, height, and sequence number. This
-        replaces the -p option. To get the equivalent:
-
-          $ ivfdec -p frame INPUT
-          $ vpxdec --i420 -o frame-%wx%h-%4.i420 INPUT
-
-    vpxenc
-      * The output file must be specified with -o, rather than as the
-        last argument.
-
-          $ ivfenc <options> INPUT OUTPUT
-          $ vpxenc <options> -o OUTPUT INPUT
-
-      * The output defaults to webm. To get IVF output, use the --ivf
-        option.
-
-          $ ivfenc <options> INPUT OUTPUT.ivf
-          $ vpxenc <options> -o OUTPUT.ivf --ivf INPUT
-
-
-  - Enhancements:
-      ivfenc and ivfdec have been renamed to vpxenc, vpxdec.
-      vpxdec supports .webm input
-      vpxdec writes .y4m by default
-      vpxenc writes .webm output by default
-      vpxenc --psnr now shows the average/overall PSNR at the end
-      ARM platforms now support runtime cpu detection
-      vpxdec visualizations added for motion vectors, block modes, references
-      vpxdec now silent by default
-      vpxdec --progress shows frame-by-frame timing information
-      vpxenc supports the distinction between --fps and --timebase
-      NASM is now a supported assembler
-      configure: enable PIC for shared libs by default
-      configure: add --enable-small
-      configure: support for ppc32-linux-gcc
-      configure: support for sparc-solaris-gcc
-
-  - Bugs:
-      Improve handling of invalid frames
-      Fix valgrind errors in the NEON loop filters.
-      Fix loopfilter delta zero transitions
-      Fix valgrind errors in vp8_sixtap_predict8x4_armv6().
-      Build fixes for darwin-icc
-
-  - Speed:
-      20-40% (average 28%) improvement in libvpx decoder speed,
-      including:
-        Rewrite vp8_short_walsh4x4_sse2()
-        Optimizations on the loopfilters.
-        Miscellaneous improvements for Atom
-        Add 4-tap version of 2nd-pass ARMv6 MC filter.
-        Improved multithread utilization
-        Better instruction choices on x86
-        reorder data to use wider instructions
-        Update NEON wide idcts
-        Make block access to frame buffer sequential
-        Improved subset block search
-        Bilinear subpixel optimizations for ssse3.
-        Decrease memory footprint
-
-      Encoder speed improvements (percentage gain not measured):
-        Skip unnecessary search of identical frames
-        Add SSE2 subtract functions
-        Improve bounds checking in vp8_diamond_search_sadx4()
-        Added vp8_fast_quantize_b_sse2
-
-  - Quality:
-      Over 7% overall PSNR improvement (6.3% SSIM) in "best" quality
-      encoding mode, and up to 60% improvement on very noisy, still
-      or slow moving source video
-
-        Motion compensated temporal filter for Alt-Ref Noise Reduction
-        Improved use of trellis quantization on 2nd order Y blocks
-        Tune effect of motion on KF/GF boost in two pass
-        Allow coefficient optimization for good quality speed 0.
-        Improved control of active min quantizer for two pass.
-        Enable ARFs for non-lagged compress
-
-2010-09-02 v0.9.2
-  - Enhancements:
-      Disable frame dropping by default
-      Improved multithreaded performance
-      Improved Force Key Frame Behaviour
-      Increased rate control buffer level precision
-      Fix bug in 1st pass motion compensation
-      ivfenc: correct fixed kf interval, --disable-kf
-  - Speed:
-      Changed above and left context data layout
-      Rework idct calling structure.
-      Removed unnecessary MB_MODE_INFO copies
-      x86: SSSE3 sixtap prediction
-      Reworked IDCT to include reconstruction (add) step
-      Swap alt/gold/new/last frame buffer ptrs instead of copying.
-      Improve SSE2 loopfilter functions
-      Change bitreader to use a larger window.
-      Avoid loopfilter reinitialization when possible
-  - Quality:
-      Normalize quantizer's zero bin and rounding factors
-      Add trellis quantization.
-      Make the quantizer exact.
-      Updates to ARNR filtering algorithm
-      Fix breakout thresh computation for golden & AltRef frames
-      Redo the forward 4x4 dct
-      Improve the accuracy of forward walsh-hadamard transform
-      Further adjustment of RD behaviour with Q and Zbin.
-  - Build System:
-      Allow linking of libs built with MinGW to MSVC
-      Fix target auto-detection on mingw32
-      Allow --cpu= to work for x86.
-      configure: pass original arguments through to make dist
-      Fix builds without runtime CPU detection
-      msvs: fix install of codec sources
-      msvs: Change devenv.com command line for better msys support
-      msvs: Add vs9 targets.
-      Add x86_64-linux-icc target
-  - Bugs:
-      Potential crashes on older MinGW builds
-      Fix two-pass framrate for Y4M input.
-      Fixed simple loop filter, other crashes on ARM v6
-      arm: fix missing dependency with --enable-shared
-      configure: support directories containing .o
-      Replace pinsrw (SSE) with MMX instructions
-      apple: include proper mach primatives
-      Fixed rate control bug with long key frame interval.
-      Fix DSO link errors on x86-64 when not using a version script
-      Fixed buffer selection for UV in AltRef filtering
-
-
-2010-06-17 v0.9.1
-  - Enhancements:
-      * ivfenc/ivfdec now support YUV4MPEG2 input and pipe I/O
-      * Speed optimizations
-  - Bugfixes:
-      * Rate control
-      * Prevent out-of-bounds accesses on invalid data
-  - Build system updates:
-      * Detect toolchain to be used automatically for native builds
-      * Support building shared libraries
-      * Better autotools emulation (--prefix, --libdir, DESTDIR)
-  - Updated LICENSE
-      * http://webmproject.blogspot.com/2010/06/changes-to-webm-open-source-license.html
-
-
-2010-05-18 v0.9.0
-  - Initial open source release. Welcome to WebM and VP8!
-
--- aom-1.0.0.errata1.orig/CMakeLists.txt
+++ aom-1.0.0.errata1/CMakeLists.txt
@@ -565,9 +565,7 @@ endif()
 
 if(HAVE_PTHREAD_H AND CONFIG_MULTITHREAD)
   find_package(Threads)
-  foreach(app_target ${AOM_APP_TARGETS})
-    target_link_libraries(${app_target} ${AOM_LIB_LINK_TYPE} Threads::Threads)
-  endforeach()
+  target_link_libraries(aom ${AOM_LIB_LINK_TYPE} Threads::Threads)
 endif()
 
 if(XCODE)
--- aom-1.0.0.errata1.orig/aom/exports_com
+++ aom-1.0.0.errata1/aom/exports_com
@@ -17,6 +17,7 @@ text aom_img_plane_height
 text aom_img_set_rect
 text aom_img_wrap
 text aom_img_alloc_with_border
+text aom_malloc
 text aom_uleb_decode
 text aom_uleb_encode
 text aom_uleb_encode_fixed_size
--- aom-1.0.0.errata1.orig/aom/exports_dec
+++ aom-1.0.0.errata1/aom/exports_dec
@@ -6,3 +6,5 @@ text aom_codec_peek_stream_info
 text aom_codec_register_put_frame_cb
 text aom_codec_register_put_slice_cb
 text aom_codec_set_frame_buffer_functions
+text aom_obu_type_to_string
+text aom_read_obu_header
--- aom-1.0.0.errata1.orig/aom/exports_enc
+++ aom-1.0.0.errata1/aom/exports_enc
@@ -7,3 +7,14 @@ text aom_codec_get_cx_data
 text aom_codec_get_global_headers
 text aom_codec_get_preview_frame
 text aom_codec_set_cx_data_buf
+text aom_film_grain_table_append
+text aom_film_grain_table_free
+text aom_film_grain_table_write
+text aom_flat_block_finder_init
+text aom_flat_block_finder_run
+text aom_noise_model_init
+text aom_noise_model_get_grain_parameters
+text aom_noise_model_save_latest
+text aom_noise_model_update
+text aom_wb_write_literal
+text aom_wb_write_unsigned_literal
--- aom-1.0.0.errata1.orig/av1/av1.cmake
+++ aom-1.0.0.errata1/av1/av1.cmake
@@ -421,13 +421,13 @@ function(setup_av1_targets)
 
   if(HAVE_NEON)
     if(AOM_AV1_COMMON_INTRIN_NEON)
-      add_intrinsics_object_library("${AOM_INTRIN_NEON_FLAG}" "neon"
+      add_intrinsics_object_library("${AOM_NEON_INTRIN_FLAG}" "neon"
                                     "aom_av1_common"
                                     "AOM_AV1_COMMON_INTRIN_NEON" "aom")
     endif()
 
     if(AOM_AV1_ENCODER_INTRIN_NEON)
-      add_intrinsics_object_library("${AOM_INTRIN_NEON_FLAG}" "neon"
+      add_intrinsics_object_library("${AOM_NEON_INTRIN_FLAG}" "neon"
                                     "aom_av1_encoder"
                                     "AOM_AV1_ENCODER_INTRIN_NEON" "aom")
     endif()
--- aom-1.0.0.errata1.orig/av1/common/ppc/cfl_ppc.c
+++ aom-1.0.0.errata1/av1/common/ppc/cfl_ppc.c
@@ -24,19 +24,21 @@
 #define CFL_LINE_2 128
 #define CFL_LINE_3 192
 
-typedef vector int8_t int8x16_t;
-typedef vector uint8_t uint8x16_t;
-typedef vector int16_t int16x8_t;
-typedef vector uint16_t uint16x8_t;
-typedef vector int32_t int32x4_t;
-typedef vector uint32_t uint32x4_t;
-typedef vector uint64_t uint64x2_t;
+typedef vector signed char int8x16_t;          // NOLINT(runtime/int)
+typedef vector unsigned char uint8x16_t;       // NOLINT(runtime/int)
+typedef vector signed short int16x8_t;         // NOLINT(runtime/int)
+typedef vector unsigned short uint16x8_t;      // NOLINT(runtime/int)
+typedef vector signed int int32x4_t;           // NOLINT(runtime/int)
+typedef vector unsigned int uint32x4_t;        // NOLINT(runtime/int)
+typedef vector unsigned long long uint64x2_t;  // NOLINT(runtime/int)
 
-static INLINE void subtract_average_vsx(int16_t *pred_buf, int width,
-                                        int height, int round_offset,
+static INLINE void subtract_average_vsx(const uint16_t *src_ptr, int16_t *dst,
+                                        int width, int height, int round_offset,
                                         int num_pel_log2) {
-  const int16_t *end = pred_buf + height * CFL_BUF_LINE;
-  const int16_t *sum_buf = pred_buf;
+  //  int16_t *dst = dst_ptr;
+  const int16_t *dst_end = dst + height * CFL_BUF_LINE;
+  const int16_t *sum_buf = (const int16_t *)src_ptr;
+  const int16_t *end = sum_buf + height * CFL_BUF_LINE;
   const uint32x4_t div_shift = vec_splats((uint32_t)num_pel_log2);
   const uint8x16_t mask_64 = { 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                                0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 };
@@ -71,43 +73,40 @@ static INLINE void subtract_average_vsx(
   const int32x4_t avg = vec_sr(sum_32x4, div_shift);
   const int16x8_t vec_avg = vec_pack(avg, avg);
   do {
-    vec_vsx_st(vec_sub(vec_vsx_ld(OFF_0, pred_buf), vec_avg), OFF_0, pred_buf);
-    vec_vsx_st(vec_sub(vec_vsx_ld(OFF_0 + CFL_LINE_1, pred_buf), vec_avg),
-               OFF_0 + CFL_BUF_LINE_BYTES, pred_buf);
-    vec_vsx_st(vec_sub(vec_vsx_ld(OFF_0 + CFL_LINE_2, pred_buf), vec_avg),
-               OFF_0 + CFL_LINE_2, pred_buf);
-    vec_vsx_st(vec_sub(vec_vsx_ld(OFF_0 + CFL_LINE_3, pred_buf), vec_avg),
-               OFF_0 + CFL_LINE_3, pred_buf);
+    vec_vsx_st(vec_sub(vec_vsx_ld(OFF_0, dst), vec_avg), OFF_0, dst);
+    vec_vsx_st(vec_sub(vec_vsx_ld(OFF_0 + CFL_LINE_1, dst), vec_avg),
+               OFF_0 + CFL_BUF_LINE_BYTES, dst);
+    vec_vsx_st(vec_sub(vec_vsx_ld(OFF_0 + CFL_LINE_2, dst), vec_avg),
+               OFF_0 + CFL_LINE_2, dst);
+    vec_vsx_st(vec_sub(vec_vsx_ld(OFF_0 + CFL_LINE_3, dst), vec_avg),
+               OFF_0 + CFL_LINE_3, dst);
     if (width >= 16) {
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_1, pred_buf), vec_avg), OFF_1,
-                 pred_buf);
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_1 + CFL_LINE_1, pred_buf), vec_avg),
-                 OFF_1 + CFL_LINE_1, pred_buf);
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_1 + CFL_LINE_2, pred_buf), vec_avg),
-                 OFF_1 + CFL_LINE_2, pred_buf);
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_1 + CFL_LINE_3, pred_buf), vec_avg),
-                 OFF_1 + CFL_LINE_3, pred_buf);
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_1, dst), vec_avg), OFF_1, dst);
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_1 + CFL_LINE_1, dst), vec_avg),
+                 OFF_1 + CFL_LINE_1, dst);
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_1 + CFL_LINE_2, dst), vec_avg),
+                 OFF_1 + CFL_LINE_2, dst);
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_1 + CFL_LINE_3, dst), vec_avg),
+                 OFF_1 + CFL_LINE_3, dst);
     }
     if (width == 32) {
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_2, pred_buf), vec_avg), OFF_2,
-                 pred_buf);
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_2 + CFL_LINE_1, pred_buf), vec_avg),
-                 OFF_2 + CFL_LINE_1, pred_buf);
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_2 + CFL_LINE_2, pred_buf), vec_avg),
-                 OFF_2 + CFL_LINE_2, pred_buf);
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_2 + CFL_LINE_3, pred_buf), vec_avg),
-                 OFF_2 + CFL_LINE_3, pred_buf);
-
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_3, pred_buf), vec_avg), OFF_3,
-                 pred_buf);
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_3 + CFL_LINE_1, pred_buf), vec_avg),
-                 OFF_3 + CFL_LINE_1, pred_buf);
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_3 + CFL_LINE_2, pred_buf), vec_avg),
-                 OFF_3 + CFL_LINE_2, pred_buf);
-      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_3 + CFL_LINE_3, pred_buf), vec_avg),
-                 OFF_3 + CFL_LINE_3, pred_buf);
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_2, dst), vec_avg), OFF_2, dst);
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_2 + CFL_LINE_1, dst), vec_avg),
+                 OFF_2 + CFL_LINE_1, dst);
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_2 + CFL_LINE_2, dst), vec_avg),
+                 OFF_2 + CFL_LINE_2, dst);
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_2 + CFL_LINE_3, dst), vec_avg),
+                 OFF_2 + CFL_LINE_3, dst);
+
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_3, dst), vec_avg), OFF_3, dst);
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_3 + CFL_LINE_1, dst), vec_avg),
+                 OFF_3 + CFL_LINE_1, dst);
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_3 + CFL_LINE_2, dst), vec_avg),
+                 OFF_3 + CFL_LINE_2, dst);
+      vec_vsx_st(vec_sub(vec_vsx_ld(OFF_3 + CFL_LINE_3, dst), vec_avg),
+                 OFF_3 + CFL_LINE_3, dst);
     }
-  } while ((pred_buf += CFL_BUF_LINE * 4) < end);
+  } while ((dst += CFL_BUF_LINE * 4) < dst_end);
 }
 
 // Declare wrappers for VSX sizes
--- /dev/null
+++ aom-1.0.0.errata1/av1/exports_com
@@ -0,0 +1 @@
+text av1_resize_frame420
--- aom-1.0.0.errata1.orig/av1/exports_dec
+++ aom-1.0.0.errata1/av1/exports_dec
@@ -1,2 +1,3 @@
 data aom_codec_av1_dx_algo
 text aom_codec_av1_dx
+text av1_add_film_grain
--- aom-1.0.0.errata1.orig/build/cmake/aom_optimization.cmake
+++ aom-1.0.0.errata1/build/cmake/aom_optimization.cmake
@@ -83,24 +83,20 @@ function(get_asm_obj_format out_format)
   if("${AOM_TARGET_CPU}" STREQUAL "x86_64")
     if("${AOM_TARGET_SYSTEM}" STREQUAL "Darwin")
       set(objformat "macho64")
-    elseif("${AOM_TARGET_SYSTEM}" STREQUAL "Linux")
-      set(objformat "elf64")
     elseif("${AOM_TARGET_SYSTEM}" STREQUAL "MSYS" OR "${AOM_TARGET_SYSTEM}"
            STREQUAL "Windows")
       set(objformat "win64")
     else()
-      message(FATAL_ERROR "Unknown obj format: ${AOM_TARGET_SYSTEM}")
+      set(objformat "elf64")
     endif()
   elseif("${AOM_TARGET_CPU}" STREQUAL "x86")
     if("${AOM_TARGET_SYSTEM}" STREQUAL "Darwin")
       set(objformat "macho32")
-    elseif("${AOM_TARGET_SYSTEM}" STREQUAL "Linux")
-      set(objformat "elf32")
     elseif("${AOM_TARGET_SYSTEM}" STREQUAL "MSYS" OR "${AOM_TARGET_SYSTEM}"
            STREQUAL "Windows")
       set(objformat "win32")
     else()
-      message(FATAL_ERROR "Unknown obj format: ${AOM_TARGET_SYSTEM}")
+      set(objformat "elf32")
     endif()
   else()
     message(FATAL_ERROR
@@ -171,7 +167,13 @@ function(test_nasm)
         message(FATAL_ERROR
                   "Unsupported nasm: macho32 object format not supported.")
       endif()
-    elseif("${AOM_TARGET_SYSTEM}" STREQUAL "Linux")
+    elseif("${AOM_TARGET_SYSTEM}" STREQUAL "MSYS" OR "${AOM_TARGET_SYSTEM}"
+           STREQUAL "Windows")
+      if(NOT "${nasm_helptext}" MATCHES "win32")
+        message(FATAL_ERROR
+                  "Unsupported nasm: win32 object format not supported.")
+      endif()
+    else()
       if(NOT "${nasm_helptext}" MATCHES "elf32")
         message(FATAL_ERROR
                   "Unsupported nasm: elf32 object format not supported.")
@@ -183,7 +185,13 @@ function(test_nasm)
         message(FATAL_ERROR
                   "Unsupported nasm: macho64 object format not supported.")
       endif()
-    elseif("${AOM_TARGET_SYSTEM}" STREQUAL "Linux")
+    elseif("${AOM_TARGET_SYSTEM}" STREQUAL "MSYS" OR "${AOM_TARGET_SYSTEM}"
+           STREQUAL "Windows")
+      if(NOT "${nasm_helptext}" MATCHES "win64")
+        message(FATAL_ERROR
+                  "Unsupported nasm: win64 object format not supported.")
+      endif()
+    else()
       if(NOT "${nasm_helptext}" MATCHES "elf64")
         message(FATAL_ERROR
                   "Unsupported nasm: elf64 object format not supported.")
--- aom-1.0.0.errata1.orig/build/cmake/exports_sources.cmake
+++ aom-1.0.0.errata1/build/cmake/exports_sources.cmake
@@ -13,14 +13,16 @@ if(AOM_BUILD_CMAKE_EXPORTS_SOURCES_CMAKE
 endif() # AOM_BUILD_CMAKE_EXPORTS_SOURCES_CMAKE_
 set(AOM_BUILD_CMAKE_EXPORTS_SOURCES_CMAKE_ 1)
 
-set(AOM_EXPORTS_SOURCES "${AOM_ROOT}/aom/exports_com")
+list(APPEND AOM_EXPORTS_SOURCES "${AOM_ROOT}/aom/exports_com"
+            "${AOM_ROOT}/av1/exports_com")
 
 if(CONFIG_AV1_DECODER)
-  set(AOM_EXPORTS_SOURCES ${AOM_EXPORTS_SOURCES} "${AOM_ROOT}/aom/exports_dec"
-      "${AOM_ROOT}/av1/exports_dec")
+  list(APPEND AOM_EXPORTS_SOURCES "${AOM_ROOT}/aom/exports_dec"
+              "${AOM_ROOT}/av1/exports_dec")
 endif()
 
 if(CONFIG_AV1_ENCODER)
-  set(AOM_EXPORTS_SOURCES ${AOM_EXPORTS_SOURCES} "${AOM_ROOT}/aom/exports_enc"
-      "${AOM_ROOT}/av1/exports_enc")
+  list(APPEND AOM_EXPORTS_SOURCES "${AOM_ROOT}/aom/exports_enc"
+              "${AOM_ROOT}/av1/exports_enc")
 endif()
+
--- aom-1.0.0.errata1.orig/build/cmake/generate_exports.cmake
+++ aom-1.0.0.errata1/build/cmake/generate_exports.cmake
@@ -39,7 +39,7 @@ elseif("${AOM_TARGET_SYSTEM}" MATCHES "W
   file(WRITE "${aom_sym_file}" "LIBRARY libaom INITINSTANCE TERMINSTANCE\n"
              "DATA MULTIPLE NONSHARED\n" "EXPORTS\n")
 else()
-  file(WRITE "${aom_sym_file}" "{ global:\n")
+  file(WRITE "${aom_sym_file}" "{\nglobal:\n")
 endif()
 
 foreach(export_file ${AOM_EXPORTS_SOURCES})
@@ -51,10 +51,10 @@ endforeach()
 foreach(exported_symbol ${exported_symbols})
   string(STRIP "${exported_symbol}" exported_symbol)
   string(REGEX REPLACE "text \|data " "" "exported_symbol" "${exported_symbol}")
-  set(exported_symbol "${symbol_prefix}${exported_symbol}${symbol_suffix}")
+  set(exported_symbol "  ${symbol_prefix}${exported_symbol}${symbol_suffix}")
   file(APPEND "${aom_sym_file}" "${exported_symbol}\n")
 endforeach()
 
 if("${aom_sym_file}" MATCHES "ver$")
-  file(APPEND "${aom_sym_file}" " };")
+  file(APPEND "${aom_sym_file}" " \nlocal:\n  *;\n};")
 endif()
--- aom-1.0.0.errata1.orig/build/cmake/toolchains/armv7-linux-gcc.cmake
+++ aom-1.0.0.errata1/build/cmake/toolchains/armv7-linux-gcc.cmake
@@ -28,16 +28,13 @@ endif()
 set(CMAKE_C_COMPILER ${CROSS}gcc)
 set(CMAKE_CXX_COMPILER ${CROSS}g++)
 set(AS_EXECUTABLE ${CROSS}as)
-set(CMAKE_C_COMPILER_ARG1
-    "-march=armv7-a -mfpu=neon ${AOM_EXTRA_TOOLCHAIN_FLAGS}")
-set(CMAKE_CXX_COMPILER_ARG1
-    "-march=armv7-a -mfpu=neon ${AOM_EXTRA_TOOLCHAIN_FLAGS}")
+set(CMAKE_C_COMPILER_ARG1 "-march=armv7-a ${AOM_EXTRA_TOOLCHAIN_FLAGS}")
+set(CMAKE_CXX_COMPILER_ARG1 "-march=armv7-a ${AOM_EXTRA_TOOLCHAIN_FLAGS}")
 set(AOM_AS_FLAGS --defsym ARCHITECTURE=7 -march=armv7-a -mfpu=neon
     ${AOM_EXTRA_TOOLCHAIN_FLAGS})
 set(CMAKE_SYSTEM_PROCESSOR "armv7")
 
-# No intrinsics flag required for armv7-linux-gcc.
-set(AOM_NEON_INTRIN_FLAG "")
+set(AOM_NEON_INTRIN_FLAG "-mfpu=neon")
 
 # No runtime cpu detect for armv7-linux-gcc.
 set(CONFIG_RUNTIME_CPU_DETECT 0 CACHE NUMBER "")
